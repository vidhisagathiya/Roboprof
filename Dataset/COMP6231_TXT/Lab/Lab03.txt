COMP6721 Applied Artificial Intelligence (Fall 2023)Lab Exercise #3: MiniMax and Alpha-Beta PruningSolutionsQuestion 1 (a) Consider the game tree shown below. Explore the tree using Alpha-Beta.Indicate all parts of the tree that are pruned, and indicate the winningpath or paths.1(b) Now do the same for the tree below, which is a mirror image of the treeshown above.2(c) Compare the amount of pruning in the above two trees. What do younotice about how the order of evaluation nodes affects the amount ofAlpha-Beta pruning?If the evaluated nodes are ordered in the manner described below, thenalpha-beta gets maximal pruning.You get maximal cutoff if the left-most descendent of a MAX node hasthe largest e(n) value compared to its siblings. For a MIN level, you getmaximal pruning if the left-most descendent has the lowest e(n) valuecompared to its siblings.Question 2 Consider the game tree below. Each node is labelled with a letter, and theevaluation function for each leaf is indicated in parentheses. Assume that theMAX player goes first.(a) Compute the minimax game value of nodes A, B, C, and D using theminimax algorithm. Show all values that are brought up to the internalnodes. What should MAX do?MAX should go right towards state D.3(b) Cross out the branches of all the nodes that are not visited by alpha-betapruning. Show all your work.4(c) Draw a new game tree by re-ordering the children of each internal nodes(B to M), such that the new game tree is equivalent to the tree above,but alpha-beta pruning will prune as many nodes as possible.This is an optimal tree, other trees could also be optimal for pruning.5Question 3 Now consider the following game tree.The value of the evaluation function at each node is shown next to its name.For example, B-4 indicates that node B has an evaluation function of 4. Allevaluations are from the point of view of the first player.(a) Assume that the first player is the maximizing player MAX and she looksat all levels (ie, to the level labeled L, M, N, O, . . . ). List in order thestates that will NOT be examined when using alpha-beta pruning.(b) What move should MAX choose?(c) Suppose that instead of looking down all levels, MAX can only afford tolook at level 2 (ie, the level with E, F, G, H, . . . instead of the level withL, M, N, O. . . ). In theory, could that change MAX’s move? Explain.(a) Nodes that will not be visited are: Q I T U K Y X(b) MAX should choose to move left (node B)(c) Yes. MAX’s best move could change. The deeper a player can afford tolook ahead, the more informed will be the player’s decision.6Question 4 Consider state space search for the game of Tic-Tac-Toe. You are the Xplayer, looking at the board shown below, with five possible moves. You wantto look ahead to find your best move and decide to use the following evaluationfunction for rating board configurations:value V = 0for all rows, columns, diagonals R do:if R contains three Xs then:V = V + 1000else if R contains three 0s then:V = V − 1000else if R contains two Xs then:V = V + 100else if R contains two Os then:V = V − 100else if R contains one X then:V = V + 10else if R contains one O then:V = V − 10end ifend forreturn V(a) Draw the four possible configurations for the leftmost and the rightmostboard configurations below. Use the evaluation function above to ratethese 8 board configurations and choose X’s best move.78Question 5 Let’s create a minimal Python implementation for the alpha-beta algorithmto better understand how it works. We’ll use a simple tree representationusing integers:# ASCII Diagram of the game tree## MAX# / | \# / | \# / | \# / | \# MIN MIN MIN# / \ / \ / \# 5 8 4 2 3 7tree = [[5, 8], [4, 2], [3, 7]]We want to be able to find the next best move on this tree by calling:best_move = alpha_beta_search(tree, 2, float('-inf'), float('inf'), True)print(f"The optimal value (best move) for the root node is: {best_move}")Here’s part of the implementation. Note that it adds some debug output sothat you can follow its execution on a given tree. Feel free to add more printstatements:def alpha_beta_search(node, depth, alpha, beta, maximizing_player):if depth == 0 or not isinstance(node, list):print(f"Evaluating node with value {node}. Alpha: {alpha}, Beta: {↪→ beta}")return nodeif maximizing_player:max_eval = float('-inf')for child in node:eval = alpha_beta_search(child, depth-1, alpha, beta, False)max_eval = max(max_eval, eval)alpha = max(alpha, eval)if beta <= alpha:print(f"Pruning branch at node with max_eval {max_eval} due to↪→ beta <= alpha. Alpha: {alpha}, Beta: {beta}")breakreturn max_evalelse:# YOUR_CODE_HERE9Here’s the missing code:min_eval = float('inf')for child in node:eval = alpha_beta_search(child, depth-1, alpha, beta, True)min_eval = min(min_eval, eval)beta = min(beta, eval)if beta <= alpha:print(f"Pruning branch at node with min_eval {min_eval} due to↪→ beta <= alpha. Alpha: {alpha}, Beta: {beta}")breakreturn min_evalComplete the code and run it on the provided example tree. Is the result whatyou would expect?Your implementation should find the optimal move, left towards node 5:Evaluating node with value 5. Alpha: -inf, Beta: infEvaluating node with value 8. Alpha: -inf, Beta: 5Evaluating node with value 4. Alpha: 5, Beta: infPruning branch at node with min_eval 4 due to beta <= alpha. Alpha: 5, Beta: 4Evaluating node with value 3. Alpha: 5, Beta: infPruning branch at node with min_eval 3 due to beta <= alpha. Alpha: 5, Beta: 3The optimal value (best move) for the root node is: 510